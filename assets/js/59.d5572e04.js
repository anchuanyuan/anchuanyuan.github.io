(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{471:function(n,e,l){"use strict";l.r(e);var t=l(0),r=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"webapis06-动画函数封装-常见网页特效-触屏事件s"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webapis06-动画函数封装-常见网页特效-触屏事件s"}},[n._v("#")]),n._v(" WebAPIs06-动画函数封装-常见网页特效-触屏事件s")]),n._v(" "),e("p",[n._v("学习目标:")]),n._v(" "),e("ol",[e("li",[n._v("能够封装简单动画函数")]),n._v(" "),e("li",[n._v("能够理解缓动动画的封装")]),n._v(" "),e("li",[n._v("能够使用动画函数")]),n._v(" "),e("li",[n._v("能够写出网页轮播图案例")]),n._v(" "),e("li",[n._v("能够写出移动端触屏事件")])]),n._v(" "),e("p",[n._v("1.1. 动画函数封装")]),n._v(" "),e("p",[n._v("1.1.1 缓动效果原理")]),n._v(" "),e("p",[n._v("缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来")]),n._v(" "),e("p",[n._v("思路：")]),n._v(" "),e("ol",[e("li",[n._v("让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。")]),n._v(" "),e("li",[n._v("核心算法： (目标值 - 现在的位置)   /  10    做为每次移动的距离步长")]),n._v(" "),e("li",[n._v("停止的条件是： 让当前盒子位置等于目标位置就停止定时器")]),n._v(" "),e("li",[n._v("注意步长值需要取整")])]),n._v(" "),e("p",[n._v("1.1.2 动画函数多个目标值之间移动")]),n._v(" "),e("p",[n._v("可以让动画函数从 800 移动到 500。")]),n._v(" "),e("p",[n._v("当我们点击按钮时候，判断步长是正值还是负值")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("1.如果是正值，则步长往大了取整\n\n2.如果是负值，则步长 向小了取整\n")])])]),e("p",[n._v("1.1.3  动函数添加回调函数")]),n._v(" "),e("p",[n._v("回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。")]),n._v(" "),e("p",[n._v("回调函数写的位置：定时器结束的位置。")]),n._v(" "),e("p",[n._v("1.1.4  动画完整版代码:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("function animate(obj, target, callback) {\n    // console.log(callback);  callback = function() {}  调用的时候 callback()\n\n    // 先清除以前的定时器，只保留当前的一个定时器执行\n    clearInterval(obj.timer);\n    obj.timer = setInterval(function() {\n        // 步长值写到定时器的里面\n        // 把我们步长值改为整数 不要出现小数的问题\n        // var step = Math.ceil((target - obj.offsetLeft) / 10);\n        var step = (target - obj.offsetLeft) / 10;\n        step = step  0 ? Math.ceil(step) : Math.floor(step);\n        if (obj.offsetLeft == target) {\n            // 停止动画 本质是停止定时器\n            clearInterval(obj.timer);\n            // 回调函数写到定时器结束里面\n            // if (callback) {\n            //     // 调用函数\n            //     callback();\n            // }\n            callback && callback();\n        }\n        // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10\n        obj.style.left = obj.offsetLeft + step + 'px';\n\n    }, 15);\n}\n")])])]),e("p",[n._v("1.2. 常见网页特效案例")]),n._v(" "),e("p",[n._v("1.2.1 案例：网页轮播图")]),n._v(" "),e("p",[n._v("轮播图也称为焦点图，是网页中比较常见的网页特效。")]),n._v(" "),e("p",[n._v("功能需求：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("1.鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。\n\n2.点击右侧按钮一次，web_API第6天图片往左播放一张，以此类推，左侧按钮同理。\n\n3.web_API第6天图片播放的同时，下面小圆圈模块跟随一起变化。\n\n4.点击小圆圈，可以播放相应web_API第6天图片。\n\n5.鼠标不经过轮播图，轮播图也会自动播放web_API第6天图片。\n\n6.鼠标经过，轮播图模块， 自动播放停止。\n\nwindow.addEventListener('load', function() {\n    // 1. 获取元素\n    var arrow_l = document.querySelector('.arrow-l');\n    var arrow_r = document.querySelector('.arrow-r');\n    var focus = document.querySelector('.focus');\n    var focusWidth = focus.offsetWidth;\n    // 2. 鼠标经过focus 就显示隐藏左右按钮\n    focus.addEventListener('mouseenter', function() {\n        arrow_l.style.display = 'block';\n        arrow_r.style.display = 'block';\n        clearInterval(timer);\n        timer = null; // 清除定时器变量\n    });\n    focus.addEventListener('mouseleave', function() {\n        arrow_l.style.display = 'none';\n        arrow_r.style.display = 'none';\n        timer = setInterval(function() {\n            //手动调用点击事件\n            arrow_r.click();\n        }, 2000);\n    });\n    // 3. 动态生成小圆圈  有几张web_API第6天图片，我就生成几个小圆圈\n    var ul = focus.querySelector('ul');\n    var ol = focus.querySelector('ol');\n    // console.log(ul.children.length);\n    for (var i = 0; i < ul.children.length; i++) {\n        // 创建一个小li \n        var li = document.createElement('li');\n        // 记录当前小圆圈的索引号 通过自定义属性来做 \n        li.setAttribute('index', i);\n        // 把小li插入到ol 里面\n        ol.appendChild(li);\n        // 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件\n        li.addEventListener('click', function() {\n            // 干掉所有人 把所有的小li 清除 current 类名\n            for (var i = 0; i < ol.children.length; i++) {\n                ol.children[i].className = '';\n            }\n            // 留下我自己  当前的小li 设置current 类名\n            this.className = 'current';\n            // 5. 点击小圆圈，移动web_API第6天图片 当然移动的是 ul \n            // ul 的移动距离 小圆圈的索引号 乘以 web_API第6天图片的宽度 注意是负值\n            // 当我们点击了某个小li 就拿到当前小li 的索引号\n            var index = this.getAttribute('index');\n            // 当我们点击了某个小li 就要把这个li 的索引号给 num  \n            num = index;\n            // 当我们点击了某个小li 就要把这个li 的索引号给 circle  \n            circle = index;\n            // num = circle = index;\n            console.log(focusWidth);\n            console.log(index);\n\n            animate(ul, -index * focusWidth);\n        })\n    }\n    // 把ol里面的第一个小li设置类名为 current\n    ol.children[0].className = 'current';\n    // 6. 克隆第一张web_API第6天图片(li)放到ul 最后面\n    var first = ul.children[0].cloneNode(true);\n    ul.appendChild(first);\n    // 7. 点击右侧按钮， web_API第6天图片滚动一张\n    var num = 0;\n    // circle 控制小圆圈的播放\n    var circle = 0;\n    // flag 节流阀\n    var flag = true;\n    arrow_r.addEventListener('click', function() {\n        if (flag) {\n            flag = false; // 关闭节流阀\n            // 如果走到了最后复制的一张web_API第6天图片，此时 我们的ul 要快速复原 left 改为 0\n            if (num == ul.children.length - 1) {\n                ul.style.left = 0;\n                num = 0;\n            }\n            num++;\n            animate(ul, -num * focusWidth, function() {\n                flag = true; // 打开节流阀\n            });\n            // 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放\n            circle++;\n            // 如果circle == 4 说明走到最后我们克隆的这张web_API第6天图片了 我们就复原\n            if (circle == ol.children.length) {\n                circle = 0;\n            }\n            // 调用函数\n            circleChange();\n        }\n    });\n\n    // 9. 左侧按钮做法\n    arrow_l.addEventListener('click', function() {\n        if (flag) {\n            flag = false;\n            if (num == 0) {\n                num = ul.children.length - 1;\n                ul.style.left = -num * focusWidth + 'px';\n\n            }\n            num--;\n            animate(ul, -num * focusWidth, function() {\n                flag = true;\n            });\n            // 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放\n            circle--;\n            // 如果circle < 0  说明第一张web_API第6天图片，则小圆圈要改为第4个小圆圈（3）\n            // if (circle == -1) {\n            //     circle = ol.children.length - 1;\n            // }\n            circle = circle < 0 ? ol.children.length - 1 : circle;\n            // 调用函数\n            circleChange();\n        }\n    });\n\n    function circleChange() {\n        // 先清除其余小圆圈的current类名\n        for (var i = 0; i < ol.children.length; i++) {\n            ol.children[i].className = '';\n        }\n        // 留下当前的小圆圈的current类名\n        ol.children[circle].className = 'current';\n    }\n    // 10. 自动播放轮播图\n    var timer = setInterval(function() {\n        //手动调用点击事件\n        arrow_r.click();\n    }, 2000);\n\n})\n")])])]),e("p",[n._v("1.2.2. 节流阀")]),n._v(" "),e("p",[n._v("防止轮播图按钮连续点击造成播放过快。")]),n._v(" "),e("p",[n._v("节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。")]),n._v(" "),e("p",[n._v("核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。")]),n._v(" "),e("p",[n._v("开始设置一个变量var flag= true;")]),n._v(" "),e("p",[n._v("If(flag){flag = false; do something}       关闭水龙头")]),n._v(" "),e("p",[n._v("利用回调函数动画执行完毕， flag = true     打开水龙头")]),n._v(" "),e("p",[n._v("1.2.3. 案例：返回顶部")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("带有动画的返回顶部")])]),n._v(" "),e("li",[e("p",[n._v("此时可以继续使用我们封装的动画函数")])]),n._v(" "),e("li",[e("p",[n._v("只需要把所有的left 相关的值改为 跟 页面垂直滚动距离相关就可以了")])]),n._v(" "),e("li",[e("p",[n._v("页面滚动了多少，可以通过 window.pageYOffset 得到")])]),n._v(" "),e("li",[e("p",[n._v("最后是页面滚动，使用 window.scroll(x,y)")]),n._v(" "),e("p",[n._v("//1. 获取元素\nvar sliderbar = document.querySelector('.slider-bar');\nvar banner = document.querySelector('.banner');\n// banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面\nvar bannerTop = banner.offsetTop\n// 当我们侧边栏固定定位之后应该变化的数值\nvar sliderbarTop = sliderbar.offsetTop - bannerTop;\n// 获取main 主体元素\nvar main = document.querySelector('.main');\nvar goBack = document.querySelector('.goBack');\nvar mainTop = main.offsetTop;\n// 2. 页面滚动事件 scroll\ndocument.addEventListener('scroll', function() {\n// console.log(11);\n// window.pageYOffset 页面被卷去的头部\n// console.log(window.pageYOffset);\n// 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位\nif (window.pageYOffset = bannerTop) {\nsliderbar.style.position = 'fixed';\nsliderbar.style.top = sliderbarTop + 'px';\n} else {\nsliderbar.style.position = 'absolute';\nsliderbar.style.top = '300px';\n}\n// 4. 当我们页面滚动到main盒子，就显示 goback模块\nif (window.pageYOffset = mainTop) {\ngoBack.style.display = 'block';\n} else {\ngoBack.style.display = 'none';\n}")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("         })\n         // 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方\n     goBack.addEventListener('click', function() {\n         // 里面的x和y 不跟单位的 直接写数字即可\n         // window.scroll(0, 0);\n         // 因为是窗口滚动 所以对象是window\n         animate(window, 0);\n     });\n")])])])])]),n._v(" "),e("p",[n._v("1.2.4. 案例：筋头云案例")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("利用动画函数做动画效果")])]),n._v(" "),e("li",[e("p",[n._v("原先筋斗云的起始位置是0")])]),n._v(" "),e("li",[e("p",[n._v("鼠标经过某个小li，把当前小li的offsetLeft 位置做为目标值即可")])]),n._v(" "),e("li",[e("p",[n._v("鼠标离开某个小li，就把目标值设为 0")])]),n._v(" "),e("li",[e("p",[n._v("如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置")]),n._v(" "),e("p",[n._v("window.addEventListener('load', function() {\n// 1. 获取元素\nvar cloud = document.querySelector('.cloud');\nvar c_nav = document.querySelector('.c-nav');\nvar lis = c_nav.querySelectorAll('li');\n// 2. 给所有的小li绑定事件\n// 这个current 做为筋斗云的起始位置\nvar current = 0;\nfor (var i = 0; i < lis.length; i++) {\n// (1) 鼠标经过把当前小li 的位置做为目标值\nlis[i].addEventListener('mouseenter', function() {\nanimate(cloud, this.offsetLeft);\n});\n// (2) 鼠标离开就回到起始的位置\nlis[i].addEventListener('mouseleave', function() {\nanimate(cloud, current);\n});\n// (3) 当我们鼠标点击，就把当前位置做为目标值\nlis[i].addEventListener('click', function() {\ncurrent = this.offsetLeft;\n});\n}\n})")])])]),n._v(" "),e("p",[n._v("1.3. 触屏事件")]),n._v(" "),e("p",[n._v("1.3.1. 触屏事件概述")]),n._v(" "),e("p",[n._v("移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android和 IOS 都有。")]),n._v(" "),e("p",[n._v("touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。")]),n._v(" "),e("p",[n._v("常见的触屏事件如下：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/anchuanyuan/TuChuangForITX/main/image/202007/06/192745-8794.png",alt:"web_API第6天图片1"}})]),n._v(" "),e("p",[n._v("1.3.2. 触摸事件对象（TouchEvent）")]),n._v(" "),e("p",[n._v("TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等")]),n._v(" "),e("p",[n._v("touchstart、touchmove、touchend 三个事件都会各自有事件对象。")]),n._v(" "),e("p",[n._v("触摸事件对象重点我们看三个常见对象列表：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/anchuanyuan/TuChuangForITX/main/image/202007/06/192745-768463.png",alt:"web_API第6天图片2"}})]),n._v(" "),e("p",[n._v("因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes")]),n._v(" "),e("p",[n._v("1.3.3.案例：移动端拖动元素")]),n._v(" "),e("ol",[e("li",[n._v("touchstart、touchmove、touchend可以实现拖动元素")]),n._v(" "),e("li",[n._v("但是拖动元素需要当前手指的坐标值 我们可以使用  targetTouches[0] 里面的pageX 和 pageY")]),n._v(" "),e("li",[n._v("移动端拖动的原理：    手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离")]),n._v(" "),e("li",[n._v("手指移动的距离：  手指滑动中的位置 减去  手指刚开始触摸的位置\n拖动元素三步曲：\n（1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置\n（2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子\n（3） 离开手指 touchend:\n注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();")])])])}),[],!1,null,null,null);e.default=r.exports}}]);